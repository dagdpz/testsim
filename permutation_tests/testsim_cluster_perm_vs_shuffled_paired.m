function testsim_cluster_perm_vs_shuffled_paired
% this function runs a paired permutation test of original data vs shuffled data
% and visualizes the results
% mainly generated by Claude 3.5 Sonnet via Cursor

% Generate sample data (vectorized)
time_points = 50;
frequencies = 50;
n_sites = 30;
level_of_noise = 3;
FILL_HOLES = false; % set true to fill non-sig holes inside clusters

% Generate noise for all sites at once
actual_tf_sites = level_of_noise * randn(time_points, frequencies, n_sites);
shuffled_tf_sites = level_of_noise * randn(time_points, frequencies, n_sites);
actual_std_sites = level_of_noise * abs(randn(time_points, frequencies, n_sites));
shuffled_std_sites = level_of_noise * abs(randn(time_points, frequencies, n_sites));

% Add effects (vectorized)
effect_strength = [-2 1.5 4 4];
effect_std = [1 1 1 3]; % std per effect patch
effect_time = [3 8; 10 20; 25 30; 40 47];
effect_freq = [3 8; 10 20; 15 25; 30 33];

% Generate site-specific random variations for all effects at once
site_variations = randn(length(effect_strength), n_sites);

for i = 1:length(effect_strength)
    % Add effect with variations to all sites at once
    time_idx = effect_time(i,1):effect_time(i,2);
    freq_idx = effect_freq(i,1):effect_freq(i,2);
    
    effect_matrix = reshape(effect_strength(i) + site_variations(i,:), ...
        [1, 1, n_sites]);
    actual_tf_sites(time_idx, freq_idx, :) = ...
        actual_tf_sites(time_idx, freq_idx, :) + ...
        repmat(effect_matrix, [length(time_idx), length(freq_idx), 1]);
    
    % Scale actual std within this effect patch
    actual_std_sites(time_idx, freq_idx, :) = ...
        actual_std_sites(time_idx, freq_idx, :) * effect_std(i);
end

% Run analysis
[clusters, cluster_stats, p_values, significance_map, pos_sig_map, neg_sig_map] = ...
    tfPairedClusterPermTest(actual_tf_sites, shuffled_tf_sites, 0.05, 0.05, FILL_HOLES);
% [clusters_w, cluster_stats_w, p_values_w, significance_map_w, pos_sig_map_w, neg_sig_map_w] = ...
%    tfPairedClusterPermTest_with_std(actual_tf_sites, actual_std_sites, shuffled_tf_sites, shuffled_std_sites, 0.05, 0.05, FILL_HOLES);

% Visualization (using efficient matrix operations)
figure('Position', [100 100 1800 400]);

mean_actual = mean(actual_tf_sites, 3);
mean_shuffled = mean(shuffled_tf_sites, 3);

% Get color limits using vectorized min/max
clims = [min(min(mean_actual(:)), min(mean_shuffled(:))), ...
    max(max(mean_actual(:)), max(mean_shuffled(:)))];

% Plot mean shuffled data
subplot(1,3,1);
imagesc(mean_shuffled);
colorbar;
title('Mean of Shuffled Data Across Sites');
ylabel('Frequency');
xlabel('Time');
caxis(clims);

% Plot mean actual data
subplot(1,3,2);
h_all = imagesc(mean_actual);

% Create alpha data matrix in one operation
alpha_data = 0.5 + 0.5 * significance_map;
set(h_all, 'AlphaData', alpha_data);

hold on;
% Keep opposite-sign outlines from touching by carving a 1-pixel gap
separation_kernel = ones(3);
pos_for_plot = pos_sig_map & ~imdilate(neg_sig_map, separation_kernel);
neg_for_plot = neg_sig_map & ~imdilate(pos_sig_map, separation_kernel);
plotRegionBoundaries(pos_for_plot, [1 1 1]); % red for positive clusters
plotRegionBoundaries(neg_for_plot, [1 1 1]); % blue for negative clusters

colorbar;
title('Mean Actual Data (Î±=0.5 for non-significant)');
ylabel('Frequency');
xlabel('Time');
caxis(clims);


subplot(1,3,3);
effect_map = mean_actual - mean_shuffled; % or use t_map directly
imagesc(effect_map); % then outline with pos_sig_map / neg_sig_map
plotRegionBoundaries(pos_sig_map, [1 0 0]); % White for positive clusters
plotRegionBoundaries(neg_sig_map, [0 0 1]); % White for negative clusters

colorbar;
title('Effect Map');
ylabel('Frequency');
xlabel('Time');
caxis(clims);


% Print results
alpha = 0.05; % keep consistent with the call above
fprintf('Suprathreshold clusters (pre-correction): %d\n', length(clusters));
fprintf('Significant clusters by p-value (p<%.3f): %d\n', alpha, sum(p_values < alpha));
% Count connected components in the final significant masks (the "actual" surviving clusters)
pos_cc = bwconncomp(pos_sig_map, 8);
neg_cc = bwconncomp(neg_sig_map, 8);
fprintf('Significant POS clusters (connected components): %d\n', pos_cc.NumObjects);
fprintf('Significant NEG clusters (connected components): %d\n', neg_cc.NumObjects);

function [clusters, cluster_stats, p_values, significance_map, pos_sig_map, neg_sig_map] = tfPairedClusterPermTest(actual_tf_sites, shuffled_tf_sites, alpha, cluster_thresh, fill_holes)
% Vectorized paired time-frequency cluster-based permutation test across multiple sites
%
% Inputs:
% actual_tf_sites: 3D matrix [time x frequency x sites] of actual signals
% shuffled_tf_sites: 3D matrix [time x frequency x sites] of shuffled/control data
% alpha: significance level (e.g., 0.05)
% cluster_thresh: threshold for initial clustering (e.g., 0.05)
%
% Outputs:
% clusters: cell array of cluster indices
% cluster_stats: statistics for each cluster
% p_values: p-value for each cluster
% significance_map: binary map of significant clusters (all)
% pos_sig_map: binary map of significant positive clusters
% neg_sig_map: binary map of significant negative clusters

if ~exist('fill_holes','var') || isempty(fill_holes)
    fill_holes = false;
end

% Get dimensions
[n_time, n_freq, n_sites] = size(actual_tf_sites);
n_perms = 1000;

% Initialize random number generator for reproducibility
% rng('default');

% Step 1: Compute difference between conditions
diff_data = actual_tf_sites - shuffled_tf_sites;

% Compute original t-statistics
mean_diff = mean(diff_data, 3);
stderr_diff = std(diff_data, 0, 3) / sqrt(n_sites);
t_map = mean_diff ./ (stderr_diff + eps);
df = n_sites - 1;

% Step 2: Find clusters in original data
t_thresh_pos = tinv(1-cluster_thresh/2, df);
t_thresh_neg = tinv(cluster_thresh/2, df);

pos_thresh = t_map > t_thresh_pos;
neg_thresh = t_map < t_thresh_neg;
if fill_holes
    pos_thresh = imfill(pos_thresh, 'holes') & (t_map > 0);
    neg_thresh = imfill(neg_thresh, 'holes') & (t_map < 0);
end
% Enforce mutual exclusivity (belt-and-suspenders)
pos_thresh(neg_thresh) = false;
neg_thresh(pos_thresh) = false;

% Find clusters using connected components
pos_clusters = bwconncomp(pos_thresh, 8);
neg_clusters = bwconncomp(neg_thresh, 8);

% Enforce sign-consistent cluster membership explicitly
pos_pix = pos_clusters.PixelIdxList;
pos_pix = cellfun(@(idx) idx(pos_thresh(idx)), pos_pix, 'UniformOutput', false);
pos_pix = pos_pix(~cellfun(@isempty, pos_pix));
neg_pix = neg_clusters.PixelIdxList;
neg_pix = cellfun(@(idx) idx(neg_thresh(idx)), neg_pix, 'UniformOutput', false);
neg_pix = neg_pix(~cellfun(@isempty, neg_pix));

% Combine positive and negative clusters
n_pos_clusters = numel(pos_pix);
n_neg_clusters = numel(neg_pix);
n_clusters = n_pos_clusters + n_neg_clusters;

if n_clusters == 0
    clusters = {};
    cluster_stats = [];
    p_values = [];
    significance_map = false(n_time, n_freq);
    pos_sig_map = significance_map;
    neg_sig_map = significance_map;
    return;
end

% Store clusters and compute their statistics
clusters = [pos_pix, neg_pix];
cluster_stats = zeros(1, n_clusters);

% Compute original cluster statistics
for i = 1:n_clusters
    cluster_stats(i) = sum(t_map(clusters{i}));
end

% Step 3: Generate random sign flips per site (paired design)
% Shape: [1 x 1 x n_sites x n_perms] to preserve spatial structure
rand_signs = 2 * (rand(1, 1, n_sites, n_perms) > 0.5) - 1;

% Initialize arrays for null distribution
null_max_stats = zeros(1, n_perms);
null_min_stats = zeros(1, n_perms);

% Reshape diff_data for broadcasting
diff_data_expanded = repmat(diff_data, [1, 1, 1, n_perms]);

% Perform sign flipping for all permutations at once
perm_diffs = diff_data_expanded .* rand_signs;

% Compute t-statistics for all permutations efficiently
perm_means = mean(perm_diffs, 3);
perm_stds = std(perm_diffs, 0, 3);
perm_t_maps = perm_means ./ (perm_stds / sqrt(n_sites) + eps);
perm_t_maps = squeeze(perm_t_maps); % reshape to [time x freq x n_perms]

% Process each permutation's t-map
for p = 1:n_perms
    curr_t_map = perm_t_maps(:,:,p);
    
    % Find clusters in permuted data
    perm_pos_mask = curr_t_map > t_thresh_pos;
    perm_neg_mask = curr_t_map < t_thresh_neg;
    if fill_holes
        perm_pos_mask = imfill(perm_pos_mask, 'holes') & (curr_t_map > 0);
        perm_neg_mask = imfill(perm_neg_mask, 'holes') & (curr_t_map < 0);
    end
    perm_pos_mask(perm_neg_mask) = false;
    perm_neg_mask(perm_pos_mask) = false;
    perm_pos = bwconncomp(perm_pos_mask, 8);
    perm_neg = bwconncomp(perm_neg_mask, 8);
    
    % Compute maximum statistics for positive clusters
    if perm_pos.NumObjects > 0
        pos_stats = arrayfun(@(idx) sum(curr_t_map(perm_pos.PixelIdxList{idx})), ...
            1:perm_pos.NumObjects);
        null_max_stats(p) = max(pos_stats);
    end
    
    % Compute minimum statistics for negative clusters
    if perm_neg.NumObjects > 0
        neg_stats = arrayfun(@(idx) sum(curr_t_map(perm_neg.PixelIdxList{idx})), ...
            1:perm_neg.NumObjects);
        null_min_stats(p) = min(neg_stats);
    end
end

% Compute p-values using vectorized operations
p_values = zeros(1, n_clusters);
% For positive clusters
for i = 1:n_pos_clusters
    p_values(i) = mean(null_max_stats >= cluster_stats(i));
end

% For negative clusters
for i = (n_pos_clusters+1):n_clusters
    p_values(i) = mean(null_min_stats <= cluster_stats(i));
end

% Create significance maps (overall, pos, neg)
significance_map = false(n_time, n_freq);
pos_sig_map = false(n_time, n_freq);
neg_sig_map = false(n_time, n_freq);
for i = 1:n_clusters
    if p_values(i) < alpha
        if i <= n_pos_clusters
            pos_sig_map(clusters{i}) = true;
        else
            neg_sig_map(clusters{i}) = true;
        end
    end
end
% Enforce sign-consistency on the final masks (belt-and-suspenders)
pos_sig_map = pos_sig_map & (t_map > 0);
neg_sig_map = neg_sig_map & (t_map < 0);
significance_map = pos_sig_map | neg_sig_map;

function [clusters, cluster_stats, p_values, significance_map, pos_sig_map, neg_sig_map] = tfPairedClusterPermTest_with_std(actual_mean_sites, actual_std_sites, surrogate_mean_sites, surrogate_std_sites, alpha, cluster_thresh, fill_holes)
% Paired cluster permutation using per-site means and stds (pooled variance)
if ~exist('fill_holes','var') || isempty(fill_holes)
    fill_holes = false;
end

[n_time, n_freq, n_sites] = size(actual_mean_sites);
n_perms = 1000;
rng('default');

site_diff = actual_mean_sites - surrogate_mean_sites;
site_sigma = sqrt(actual_std_sites.^2 + surrogate_std_sites.^2 + eps);
site_z = site_diff ./ site_sigma;

mean_z = mean(site_z,3);
stderr_z = std(site_z,0,3) / sqrt(n_sites);
t_map = mean_z ./ (stderr_z + eps);
df = n_sites - 1;

t_thresh_pos = tinv(1-cluster_thresh/2, df);
t_thresh_neg = tinv(cluster_thresh/2, df);

pos_thresh = t_map > t_thresh_pos;
neg_thresh = t_map < t_thresh_neg;
if fill_holes
    pos_thresh = imfill(pos_thresh, 'holes') & (t_map > 0);
    neg_thresh = imfill(neg_thresh, 'holes') & (t_map < 0);
end
pos_thresh(neg_thresh) = false;
neg_thresh(pos_thresh) = false;

pos_clusters = bwconncomp(pos_thresh, 8);
neg_clusters = bwconncomp(neg_thresh, 8);
pos_pix = pos_clusters.PixelIdxList;
pos_pix = cellfun(@(idx) idx(pos_thresh(idx)), pos_pix, 'UniformOutput', false);
pos_pix = pos_pix(~cellfun(@isempty, pos_pix));
neg_pix = neg_clusters.PixelIdxList;
neg_pix = cellfun(@(idx) idx(neg_thresh(idx)), neg_pix, 'UniformOutput', false);
neg_pix = neg_pix(~cellfun(@isempty, neg_pix));

n_pos_clusters = numel(pos_pix);
n_neg_clusters = numel(neg_pix);
n_clusters = n_pos_clusters + n_neg_clusters;

if n_clusters == 0
    clusters = {};
    cluster_stats = [];
    p_values = [];
    significance_map = false(n_time, n_freq);
    pos_sig_map = significance_map;
    neg_sig_map = significance_map;
    return;
end

clusters = [pos_pix, neg_pix];
cluster_stats = zeros(1, n_clusters);
for i = 1:n_clusters
    cluster_stats(i) = sum(t_map(clusters{i}));
end

rand_signs = 2 * (rand(1, 1, n_sites, n_perms) > 0.5) - 1;
null_max_stats = zeros(1, n_perms);
null_min_stats = zeros(1, n_perms);

site_z_expanded = repmat(site_z, [1 1 1 n_perms]);
perm_site_z = site_z_expanded .* rand_signs;

perm_means = mean(perm_site_z, 3);
perm_stds = std(perm_site_z, 0, 3);
perm_t_maps = perm_means ./ (perm_stds / sqrt(n_sites) + eps);
perm_t_maps = squeeze(perm_t_maps);

for p = 1:n_perms
    curr_t_map = perm_t_maps(:,:,p);
    perm_pos_mask = curr_t_map > t_thresh_pos;
    perm_neg_mask = curr_t_map < t_thresh_neg;
    if fill_holes
        perm_pos_mask = imfill(perm_pos_mask, 'holes') & (curr_t_map > 0);
        perm_neg_mask = imfill(perm_neg_mask, 'holes') & (curr_t_map < 0);
    end
    perm_pos_mask(perm_neg_mask) = false;
    perm_neg_mask(perm_pos_mask) = false;
    perm_pos = bwconncomp(perm_pos_mask, 8);
    perm_neg = bwconncomp(perm_neg_mask, 8);

    if perm_pos.NumObjects > 0
        pos_stats = arrayfun(@(idx) sum(curr_t_map(perm_pos.PixelIdxList{idx})), 1:perm_pos.NumObjects);
        null_max_stats(p) = max(pos_stats);
    end
    if perm_neg.NumObjects > 0
        neg_stats = arrayfun(@(idx) sum(curr_t_map(perm_neg.PixelIdxList{idx})), 1:perm_neg.NumObjects);
        null_min_stats(p) = min(neg_stats);
    end
end

p_values = zeros(1, n_clusters);
for i = 1:n_pos_clusters
    p_values(i) = mean(null_max_stats >= cluster_stats(i));
end
for i = (n_pos_clusters+1):n_clusters
    p_values(i) = mean(null_min_stats <= cluster_stats(i));
end

significance_map = false(n_time, n_freq);
pos_sig_map = false(n_time, n_freq);
neg_sig_map = false(n_time, n_freq);
for i = 1:n_clusters
    if p_values(i) < alpha
        if i <= n_pos_clusters
            pos_sig_map(clusters{i}) = true;
        else
            neg_sig_map(clusters{i}) = true;
        end
    end
end
pos_sig_map = pos_sig_map & (t_map > 0);
neg_sig_map = neg_sig_map & (t_map < 0);
significance_map = pos_sig_map | neg_sig_map;


function plotRegionBoundaries(matrix, color)
% Get matrix dimensions
[rows, cols] = size(matrix);

if ~exist('color','var') || isempty(color)
    color = [0 0 0];
end

% Create figure and display binary matrix
% figure;
% imagesc(matrix);
% colormap([1 1 1; 0 0 1]); % White background, blue regions
% axis equal tight;
hold on;

% Create extended matrix with padding to help detect edges
padded = zeros(rows+2, cols+2);
padded(2:end-1, 2:end-1) = matrix;

% Initialize arrays to store line segments
x = [];
y = [];

% Scan for horizontal edges
for i = 1:rows
    for j = 1:cols
        if matrix(i,j) == 1
            % Check top edge
            if i == 1 || matrix(i-1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i-0.5, i-0.5, NaN];
            end
            % Check bottom edge
            if i == rows || matrix(i+1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i+0.5, i+0.5, NaN];
            end
        end
    end
end

% Scan for vertical edges
for j = 1:cols
    for i = 1:rows
        if matrix(i,j) == 1
            % Check left edge
            if j == 1 || matrix(i,j-1) == 0
                x = [x, j-0.5, j-0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
            % Check right edge
            if j == cols || matrix(i,j+1) == 0
                x = [x, j+0.5, j+0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
        end
    end
end

% Plot all edges at once
plot(x, y, 'Color', color, 'LineWidth', 2);

% Add title and adjust appearance
title('Binary Regions with Boundaries');
grid off;




