testsim_cluster_perm_two_conditions_1D_vector_valued_stats
% mainly generated by Claude 3.5 Sonnet

%% Vector-Valued Cluster-Based Permutation Test
% Complete implementation with simulated data

clear; close all; rng(42); % For reproducibility

%% ========================================================================
%  PART 1: SIMULATE DATA WITH MULTIPLE CLUSTERS
%  ========================================================================

% Parameters
n_subjects = 20;           % Number of subjects
n_timepoints = 600;        % Number of time points (e.g., 600ms at 1000Hz)
sampling_rate = 1000;      % Hz
time = (0:n_timepoints-1) / sampling_rate;

% Generate data for condition 1 (baseline)
fprintf('Generating simulated data...\n');
condition1 = randn(n_subjects, n_timepoints);

% Generate data for condition 2 (with multiple clusters of true effects)
condition2 = randn(n_subjects, n_timepoints);

% Add TRUE EFFECT CLUSTER 1: Early positive effect (100-200ms)
cluster1_time = 100:200;
cluster1_effect = 1.2; % Cohen's d ≈ 1.2
condition2(:, cluster1_time) = condition2(:, cluster1_time) + cluster1_effect;

% Add TRUE EFFECT CLUSTER 2: Mid-latency negative effect (300-450ms)
cluster2_time = 300:450;
cluster2_effect = -0.8; % Cohen's d ≈ 0.8
condition2(:, cluster2_time) = condition2(:, cluster2_time) + cluster2_effect;

% Add TRUE EFFECT CLUSTER 3: Late positive effect (500-550ms)
cluster3_time = 500:550;
cluster3_effect = 0.6; % Cohen's d ≈ 0.6
condition3(:, cluster3_time) = condition2(:, cluster3_time) + cluster3_effect;

fprintf('  True clusters inserted at:\n');
fprintf('    Cluster 1: %d-%d ms (effect size: %.2f)\n', ...
    cluster1_time(1), cluster1_time(end), cluster1_effect);
fprintf('    Cluster 2: %d-%d ms (effect size: %.2f)\n', ...
    cluster2_time(1), cluster2_time(end), cluster2_effect);
fprintf('    Cluster 3: %d-%d ms (effect size: %.2f)\n', ...
    cluster3_time(1), cluster3_time(end), cluster3_effect);

%% ========================================================================
%  PART 2: OBSERVED DATA STATISTICS
%  ========================================================================

fprintf('\nCalculating observed statistics...\n');

% Calculate observed t-values at each time point
[observed_clusters, observed_tvals] = calculate_cluster_stats(...
    condition1, condition2);

fprintf('  Found %d clusters in observed data\n', length(observed_clusters));

% Create observed vector (sorted by absolute cluster mass, descending)
[observed_vector, sort_idx] = sort(abs([observed_clusters.mass]), 'descend');
observed_clusters_sorted = observed_clusters(sort_idx);

fprintf('  Observed cluster masses: ');
fprintf('%.1f ', observed_vector);
fprintf('\n');

%% ========================================================================
%  PART 3: PERMUTATION DISTRIBUTION
%  ========================================================================

n_permutations = 1000;
fprintf('\nRunning %d permutations...\n', n_permutations);

% Initialize storage for permutation distributions
% Use cell array because different permutations may have different numbers of clusters
perm_vectors = cell(n_permutations, 1);

for perm = 1:n_permutations
    if mod(perm, 100) == 0
        fprintf('  Permutation %d/%d\n', perm, n_permutations);
    end
    
    % Randomly shuffle condition labels
    all_data = cat(3, condition1, condition2); % n_subjects x n_timepoints x 2
    shuffled_labels = randi([1, 2], n_subjects, 2); % Random assignment
    
    perm_cond1 = zeros(n_subjects, n_timepoints);
    perm_cond2 = zeros(n_subjects, n_timepoints);
    
    for subj = 1:n_subjects
        perm_cond1(subj, :) = all_data(subj, :, shuffled_labels(subj, 1));
        perm_cond2(subj, :) = all_data(subj, :, shuffled_labels(subj, 2));
    end
    
    % Calculate cluster statistics for this permutation
    [perm_clusters, ~] = calculate_cluster_stats(perm_cond1, perm_cond2);
    
    % Store as vector (sorted by absolute mass)
    if ~isempty(perm_clusters)
        perm_masses = abs([perm_clusters.mass]);
        perm_vectors{perm} = sort(perm_masses, 'descend');
    else
        perm_vectors{perm} = [];
    end
end

%% ========================================================================
%  PART 4: BUILD DIMENSION-SPECIFIC DISTRIBUTIONS
%  ========================================================================

fprintf('\nBuilding dimension-specific distributions...\n');

% Determine maximum number of dimensions to test
max_dimensions = length(observed_vector);
fprintf('  Testing up to %d dimensions\n', max_dimensions);

% Build distribution for each dimension
dimension_distributions = cell(max_dimensions, 1);

for dim = 1:max_dimensions
    dim_values = [];
    for perm = 1:n_permutations
        if length(perm_vectors{perm}) >= dim
            dim_values(end+1) = perm_vectors{perm}(dim);
        end
    end
    dimension_distributions{dim} = dim_values;
    fprintf('  Dimension %d: %d values\n', dim, length(dim_values));
end

%% ========================================================================
%  PART 5: CALCULATE CRITICAL VALUES FOR EACH DIMENSION
%  ========================================================================

alpha = 0.05;
fprintf('\nCalculating critical values (alpha = %.3f, two-sided)...\n', alpha);

critical_values = zeros(max_dimensions, 1);
for dim = 1:max_dimensions
    if ~isempty(dimension_distributions{dim})
        critical_values(dim) = prctile(dimension_distributions{dim}, ...
            100 * (1 - alpha/2)); % Two-sided test
        fprintf('  Dimension %d: CV = %.2f\n', dim, critical_values(dim));
    else
        critical_values(dim) = Inf; % No clusters at this dimension
    end
end

%% ========================================================================
%  PART 6: TEST OBSERVED CLUSTERS
%  ========================================================================

fprintf('\nTesting observed clusters against critical values...\n');

significant_clusters = false(length(observed_vector), 1);
for dim = 1:length(observed_vector)
    if observed_vector(dim) > critical_values(dim)
        significant_clusters(dim) = true;
        fprintf('  Cluster %d (dim %d): %.2f > %.2f - SIGNIFICANT\n', ...
            dim, dim, observed_vector(dim), critical_values(dim));
    else
        fprintf('  Cluster %d (dim %d): %.2f <= %.2f - Not significant\n', ...
            dim, dim, observed_vector(dim), critical_values(dim));
    end
end

%% ========================================================================
%  PART 7: CALCULATE P-VALUES FOR EACH CLUSTER
%  ========================================================================

fprintf('\nCalculating dimension-specific p-values...\n');

p_values = zeros(length(observed_vector), 1);
for dim = 1:length(observed_vector)
    if ~isempty(dimension_distributions{dim})
        % Count how many permutation values >= observed value
        n_exceed = sum(dimension_distributions{dim} >= observed_vector(dim));
        p_values(dim) = n_exceed / length(dimension_distributions{dim});
        fprintf('  Dimension %d: p = %.4f\n', dim, p_values(dim));
    else
        p_values(dim) = 1;
    end
end

%% ========================================================================
%  PART 8: VISUALIZE RESULTS
%  ========================================================================

fprintf('\nGenerating visualizations...\n');

figure('Position', [100, 100, 1400, 900]);

% Panel 1: Raw data (grand averages)
subplot(4, 2, 1);
mean_cond1 = mean(condition1, 1);
mean_cond2 = mean(condition2, 1);
plot(time, mean_cond1, 'b-', 'LineWidth', 1.5); hold on;
plot(time, mean_cond2, 'r-', 'LineWidth', 1.5);
xlabel('Time (s)'); ylabel('Amplitude');
title('Grand Average Waveforms');
legend('Condition 1', 'Condition 2');
grid on;

% Panel 2: Difference wave with true cluster locations
subplot(4, 2, 2);
diff_wave = mean_cond2 - mean_cond1;
plot(time, diff_wave, 'k-', 'LineWidth', 1.5); hold on;
plot(time, zeros(size(time)), 'k--');
% Shade true cluster locations
ylims = ylim;
patch([time(cluster1_time(1)), time(cluster1_time(end)), ...
    time(cluster1_time(end)), time(cluster1_time(1))], ...
    [ylims(1), ylims(1), ylims(2), ylims(2)], ...
    'g', 'FaceAlpha', 0.2, 'EdgeColor', 'none');
patch([time(cluster2_time(1)), time(cluster2_time(end)), ...
    time(cluster2_time(end)), time(cluster2_time(1))], ...
    [ylims(1), ylims(1), ylims(2), ylims(2)], ...
    'g', 'FaceAlpha', 0.2, 'EdgeColor', 'none');
patch([time(cluster3_time(1)), time(cluster3_time(end)), ...
    time(cluster3_time(end)), time(cluster3_time(1))], ...
    [ylims(1), ylims(1), ylims(2), ylims(2)], ...
    'g', 'FaceAlpha', 0.2, 'EdgeColor', 'none');
xlabel('Time (s)'); ylabel('Difference');
title('Difference Wave (True Clusters Shaded Green)');
grid on;

% Panel 3: T-statistic timecourse with threshold
subplot(4, 2, 3);
plot(time, observed_tvals, 'k-', 'LineWidth', 1); hold on;
t_thresh = tinv(1 - 0.025, n_subjects - 1); % Two-sided threshold
plot(time, t_thresh * ones(size(time)), 'r--', 'LineWidth', 1);
plot(time, -t_thresh * ones(size(time)), 'r--', 'LineWidth', 1);
xlabel('Time (s)'); ylabel('t-value');
title(sprintf('T-statistics (threshold = ±%.2f)', t_thresh));
grid on;

% Panel 4: Detected clusters
subplot(4, 2, 4);
plot(time, diff_wave, 'k-', 'LineWidth', 1); hold on;
plot(time, zeros(size(time)), 'k--');
ylims = ylim;
% Shade significant clusters
for i = 1:length(observed_clusters_sorted)
    if significant_clusters(i)
        cluster = observed_clusters_sorted(i);
        patch([time(cluster.timepoints(1)), time(cluster.timepoints(end)), ...
            time(cluster.timepoints(end)), time(cluster.timepoints(1))], ...
            [ylims(1), ylims(1), ylims(2), ylims(2)], ...
            'r', 'FaceAlpha', 0.3, 'EdgeColor', 'none');
    end
end
xlabel('Time (s)'); ylabel('Difference');
title('Significant Clusters (Red Shading)');
grid on;

% Panel 5: Dimension-specific distributions (first 4 dimensions)
for dim = 1:min(4, max_dimensions)
    subplot(4, 2, 4 + dim);
    if ~isempty(dimension_distributions{dim})
        histogram(dimension_distributions{dim}, 30, ...
            'FaceColor', [0.7, 0.7, 0.7], 'EdgeColor', 'k');
        hold on;
        % Mark critical value
        yl = ylim;
        plot([critical_values(dim), critical_values(dim)], yl, ...
            'r--', 'LineWidth', 2);
        % Mark observed value
        plot([observed_vector(dim), observed_vector(dim)], yl, ...
            'b-', 'LineWidth', 2);
        xlabel('Cluster Mass');
        ylabel('Count');
        title(sprintf('Dimension %d (p=%.4f)', dim, p_values(dim)));
        legend('Permutation Dist', 'Critical Value', 'Observed', ...
            'Location', 'best');
        grid on;
    end
end

sgtitle('Vector-Valued Cluster-Based Permutation Test Results', ...
    'FontSize', 14, 'FontWeight', 'bold');

%% ========================================================================
%  PART 9: SUMMARY TABLE
%  ========================================================================

fprintf('\n========================================\n');
fprintf('SUMMARY OF RESULTS\n');
fprintf('========================================\n');
fprintf('Cluster | Dimension | Time Range (ms) | Mass   | CV     | p-value | Significant\n');
fprintf('--------|-----------|-----------------|--------|--------|---------|------------\n');

for i = 1:length(observed_clusters_sorted)
    cluster = observed_clusters_sorted(i);
    time_start = cluster.timepoints(1);
    time_end = cluster.timepoints(end);
    
    fprintf('   %2d   |     %2d    |   %3d - %3d     | %6.1f | %6.1f | %.4f  |     %s\n', ...
        i, i, time_start, time_end, ...
        observed_vector(i), critical_values(i), ...
        p_values(i), ...
        char("YES" * significant_clusters(i) + "NO" * ~significant_clusters(i)));
end

fprintf('========================================\n\n');

%% ========================================================================
%  HELPER FUNCTION: CALCULATE CLUSTER STATISTICS
%  ========================================================================

function [clusters, tvals] = calculate_cluster_stats(cond1, cond2)
    % Calculate t-values at each time point
    n_subjects = size(cond1, 1);
    n_timepoints = size(cond1, 2);
    
    tvals = zeros(1, n_timepoints);
    for t = 1:n_timepoints
        [~, ~, ~, stats] = ttest(cond1(:, t), cond2(:, t));
        tvals(t) = stats.tstat;
    end
    
    % Threshold for clustering (using parametric threshold, but this
    % doesn't affect validity - only sensitivity)
    t_thresh = tinv(1 - 0.025, n_subjects - 1); % Two-sided, alpha=0.05
    
    % Find clusters of suprathreshold t-values
    clusters = [];
    
    % Positive clusters
    pos_mask = tvals > t_thresh;
    pos_clusters = find_clusters(pos_mask, tvals);
    clusters = [clusters, pos_clusters];
    
    % Negative clusters
    neg_mask = tvals < -t_thresh;
    neg_clusters = find_clusters(neg_mask, tvals);
    clusters = [clusters, neg_clusters];
end

function clusters = find_clusters(mask, tvals)
    % Find connected components in binary mask
    clusters = [];
    
    if ~any(mask)
        return;
    end
    
    % Find start and end of each cluster
    d_mask = diff([0, mask, 0]);
    starts = find(d_mask == 1);
    ends = find(d_mask == -1) - 1;
    
    % Calculate cluster mass for each cluster
    for i = 1:length(starts)
        cluster_timepoints = starts(i):ends(i);
        cluster_mass = sum(tvals(cluster_timepoints)); % Sum of t-values
        
        clusters(end+1).timepoints = cluster_timepoints;
        clusters(end).mass = cluster_mass;
        clusters(end).size = length(cluster_timepoints);
    end
end



