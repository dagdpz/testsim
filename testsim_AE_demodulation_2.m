% --- Simulation of the Entire Acoustoelectric (AE) Process ---
% Date: 2025-05-14 (Restructured for clarity: Calculate All, Then Plot All)
% Purpose: Systematically show:
%          1. An original V1 LF signal.
%          2. Generation of a small HF AE component due to US interaction (modulation).
%          3. How this AE component appears as ripples on the V1 LF signal locally.
%          4. Mixing with interference signals.
%          5. Recovery of V1 LF information from the AE component.

clear; clc; close all;

fprintf('Starting simulation: Part 1 - System Parameters & Signal Generation\n');

% --- Part 1: System Parameters & Signal Generation ---

% --- Simulation Parameters ---
Fs = 20000;                 % Sampling frequency (Hz)
T = 1;                      % Duration of signal (seconds)
t = 0:1/Fs:T-1/Fs;          % Time vector

% Frequencies
f_interfere_waves = [20, 21, 22, 27, 30, 35, 38, 40, 50]; % 9 Interfering slow waves
f_V1_target_LF = 25;         % Frequency of the V1 target low-frequency signal (Hz)
f_carrier_US = 1000;         % High-frequency ultrasound carrier (Hz)

% Amplitudes and Phases
rng(3); % Changed seed for slight variation
amps_interfere = rand(1, length(f_interfere_waves)) * 0.6 + 0.4;
phases_interfere = rand(1, length(f_interfere_waves)) * 2 * pi;

amp_V1_target_LF = 1.0;     % Amplitude of the V1 target LF signal
phase_V1_target_LF = pi/6;

amp_carrier_for_AE_effect = 1.0; % Notional amplitude for the US carrier effect in AE generation
phase_carrier_US = 0;         % Phase of the US carrier effect

modulation_index_AE = 0.7;    % Modulation index for generating the AE component
ae_signal_strength_factor = 0.01; % Factor making the AE component small

if amp_V1_target_LF == 0
    error('amp_V1_target_LF cannot be zero for normalization.');
end
fprintf('Parameters initialized.\n');

% --- Signal Generation ---
% Input: Time vector 't', frequencies, amplitudes, phases.
% Output: Individual signal components.

% 1. Original V1 Low-Frequency (LF) Signal (The "Message")
s_V1_target_LF = amp_V1_target_LF * sin(2*pi*f_V1_target_LF*t + phase_V1_target_LF);


% 2. Sum of 9 Interfering Low-Frequency Signals
s_interfere = zeros(size(t));
for i = 1:length(f_interfere_waves)
    s_interfere = s_interfere + amps_interfere(i) * sin(2*pi*f_interfere_waves(i)*t + phases_interfere(i));
end

% 3. Acoustoelectric (AE) Component Generation
% This component is the V1 LF signal's information modulated onto the US carrier frequency,
% representing the new signal generated by US interaction.
normalized_V1_LF_for_AE = s_V1_target_LF / amp_V1_target_LF; % Normalized message
s_ae_component_unscaled_am = amp_carrier_for_AE_effect * (1 + modulation_index_AE * normalized_V1_LF_for_AE) .* cos(2*pi*f_carrier_US*t + phase_carrier_US);
s_ae_component = s_ae_component_unscaled_am * ae_signal_strength_factor; % Actual small AE component


% 4. Realistic Local V1 Signal Under US Interaction
% This is the original V1 LF signal with the small HF AE component (ripples) superimposed.
s_V1_local_total_with_AE = s_V1_target_LF + s_ae_component;
if any(~isfinite(s_V1_local_total_with_AE(:))); error('s_V1_local_total_with_AE contains non-finite values!'); end;

% 5. Mixed Signal (as recorded by a distant electrode)
% Sum of the local V1 signal (which includes AE ripples) and other interferences.
% Equivalent to: s_V1_target_LF (original) + s_ae_component (ripples) + s_interfere (noise)
s_mixed = s_V1_local_total_with_AE + s_interfere;
% s_mixed = s_V1_target_LF + s_ae_component + s_interfere; % This is the same
if any(~isfinite(s_mixed(:))); error('s_mixed contains non-finite values before any filtering!'); end;
fprintf('All source signals generated and mixed signal created.\n');

% --- Part 2: AE Signal Extraction Process (Calculations Only) ---
fprintf('Part 2 - AE Signal Extraction Process Starting...\n');

% --- Stage 1: Band-Pass Filtering ---
% Input: s_mixed
% Output: s_bandpassed (isolating the s_ae_component)
filter_order_bp = 8;
bandpass_low_cutoff = f_carrier_US - 2.5*f_V1_target_LF; % e.g., 1000 - 62.5 = 937.5
bandpass_high_cutoff = f_carrier_US + 2.5*f_V1_target_LF; % e.g., 1000 + 62.5 = 1062.5
Wn_bp = [bandpass_low_cutoff bandpass_high_cutoff]/(Fs/2);
if any(Wn_bp <= 0) || any(Wn_bp >= 1); error('Normalized bandpass filter cutoffs Wn_bp are out of (0,1) range.'); end
[z_bp, p_bp, k_bp] = butter(filter_order_bp, Wn_bp, 'bandpass');
if any(~isfinite(z_bp(:))) || any(~isfinite(p_bp(:))) || any(~isfinite(k_bp(:))); error('ZPK for BPF non-finite.'); end
[sos_bp, g_bp] = zp2sos(z_bp, p_bp, k_bp);
if any(~isfinite(sos_bp(:))) || any(~isfinite(g_bp(:))); error('SOS/G for BPF non-finite.'); end
s_bandpassed = filtfilt(sos_bp, g_bp, s_mixed);
if any(~isfinite(s_bandpassed(:))); error('s_bandpassed contains non-finite values after BPF!'); end;
fprintf('BPF applied. Output: s_bandpassed.\n');

% --- Stage 2: Coherent Demodulation ---
% Input: s_bandpassed
% Output: s_multiplied
s_local_oscillator = cos(2*pi*f_carrier_US*t + phase_carrier_US); % Matched phase
s_multiplied = s_bandpassed .* s_local_oscillator;
if any(~isfinite(s_multiplied(:))); error('s_multiplied contains non-finite values before LPF!'); end;
fprintf('Coherent demodulation applied. Output: s_multiplied.\n');

% --- Stage 3: Low-Pass Filtering ---
% Input: s_multiplied
% Output: s_recovered_from_AE_raw (recovered V1 LF info from AE component)
filter_order_lp = 8;
lowpass_cutoff = 1.5 * f_V1_target_LF; % e.g., 37.5 Hz for 25Hz signal
Wn_lp = lowpass_cutoff/(Fs/2);
if Wn_lp <= 0 || Wn_lp >= 1; error('Normalized LPF cutoff Wn_lp is out of (0,1) range.'); end
[z_lp, p_lp, k_lp] = butter(filter_order_lp, Wn_lp, 'low');
if any(~isfinite(z_lp(:))) || any(~isfinite(p_lp(:))) || any(~isfinite(k_lp(:))); error('ZPK for LPF non-finite.'); end
[sos_lp, g_lp] = zp2sos(z_lp, p_lp, k_lp);
if any(~isfinite(sos_lp(:))) || any(~isfinite(g_lp(:))); error('SOS/G for LPF non-finite.'); end
s_recovered_from_AE_raw = filtfilt(sos_lp, g_lp, s_multiplied);
if any(~isfinite(s_recovered_from_AE_raw(:))); error('s_recovered_from_AE_raw contains non-finite values after LPF!'); end;
fprintf('LPF applied. Output: s_recovered_from_AE_raw.\n');

% --- Stage 4: Post-processing for Comparison ---
% Input: s_recovered_from_AE_raw, s_V1_target_LF
% Output: s_recovered_from_AE_scaled, s_V1_target_LF_ac
s_recovered_from_AE_ac = s_recovered_from_AE_raw - mean(s_recovered_from_AE_raw);
s_V1_target_LF_ac = s_V1_target_LF - mean(s_V1_target_LF); % Should be already AC but good practice

% Approximate scaling based on AM theory and ae_signal_strength_factor
% The message part of s_ae_component is (modulation_index_AE * normalized_V1_LF_for_AE) * (amp_carrier_for_AE_effect * ae_signal_strength_factor)
% After demodulation (0.5 factor): 0.5 * modulation_index_AE * (s_V1_target_LF/amp_V1_target_LF) * amp_carrier_for_AE_effect * ae_signal_strength_factor
scaling_factor_demod = (0.5 * amp_carrier_for_AE_effect * modulation_index_AE * ae_signal_strength_factor) / amp_V1_target_LF;
if abs(scaling_factor_demod) < 1e-12
    fprintf('Warning: scaling_factor_demod is very small or zero (%g). Setting to 1.\n', scaling_factor_demod);
    scaling_factor_demod = 1;
end
s_recovered_from_AE_scaled = s_recovered_from_AE_ac / scaling_factor_demod;
if any(~isfinite(s_recovered_from_AE_scaled(:))); error('s_recovered_from_AE_scaled contains non-finite values!'); end;
fprintf('Post-processing for comparison complete.\n');

% --- Part 3: Plotting ---
fprintf('Part 3 - Plotting all stages...\n');

% --- Plotting Details for consistent visualization ---
xlim_time_detail = [0, 0.2]; % 200ms for general time domain view
xlim_time_ripple_zoom = [0.01, 0.01 + 2*(1/f_V1_target_LF)]; % Zoom to see ripples on LF
xlim_time_full = [0, T];     % Show full duration for final comparison

% --- Figure 1: Signal Generation Stages & The "Ripple Effect" ---
figure('Name', 'Figure 1: Source Signals & Local V1 Signal with AE Ripples', 'Position', [50, 100, 1200, 950]);
sgtitle('Signal Generation & Local V1 Interaction Effect', 'FontSize', 15, 'FontWeight', 'bold');

% Row 1: Original V1 Low-Frequency Signal
subplot(4,2,1); plot(t, s_V1_target_LF); title('1a. Original Endogenous V1 LF Signal');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
ylim_lf = [-amp_V1_target_LF*1.1, amp_V1_target_LF*1.1]; if ylim_lf(1)==ylim_lf(2); ylim_lf = [-1 1]; end; ylim(ylim_lf);
subplot(4,2,2); plot_spectrum_local(s_V1_target_LF, Fs, '1b. Spectrum of Original V1 LF Signal');
xlim([0 100]); grid on;

% Row 2: Small High-Frequency AE Component (Source of Ripples)
subplot(4,2,3); plot(t, s_ae_component); title('2a. Small HF AE Component (Generated by US)');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
ylim_hf_ripple = [-max(abs(s_ae_component))*1.5, max(abs(s_ae_component))*1.5]; if ylim_hf_ripple(1)==ylim_hf_ripple(2); ylim_hf_ripple = [-0.1 0.1]; end; ylim(ylim_hf_ripple);
subplot(4,2,4); plot_spectrum_local(s_ae_component, Fs, '2b. Spectrum of Small HF AE Component');
xlim([f_carrier_US - 4*f_V1_target_LF, f_carrier_US + 4*f_V1_target_LF]); grid on;

% Row 3: Realistic Local V1 Signal (V1 LF + AE Ripples)
subplot(4,2,5); plot(t, s_V1_local_total_with_AE); title('3a. Local V1 Signal with AE Ripples');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail); ylim(ylim_lf);
% Inset for ripples
axes_pos = get(gca,'Position');
h_inset = axes('Position',[axes_pos(1)+0.23 axes_pos(2)+0.02 0.15 0.12]); % Adjusted position
plot(h_inset, t, s_V1_local_total_with_AE);
xlim(h_inset, xlim_time_ripple_zoom);
segment_indices_inset = t >= xlim_time_ripple_zoom(1) & t <= xlim_time_ripple_zoom(2);
segment_data_inset = s_V1_local_total_with_AE(segment_indices_inset);
if ~isempty(segment_data_inset)
    min_val_inset = min(segment_data_inset); max_val_inset = max(segment_data_inset);
    padding_inset = max(abs(s_ae_component)) * 2; if padding_inset == 0; padding_inset = 0.005*amp_V1_target_LF; end;
    ylim(h_inset, [min_val_inset - padding_inset, max_val_inset + padding_inset]);
else; ylim(h_inset, [-0.1*amp_V1_target_LF, 0.1*amp_V1_target_LF]); end
title(h_inset,'Zoom: Ripples','FontSize',8); grid(h_inset, 'on'); set(h_inset,'XTickLabel',[],'YTickLabel',[]);

subplot(4,2,6); plot_spectrum_local(s_V1_local_total_with_AE, Fs, '3b. Spectrum of Local V1 with AE');
xlim([0 f_carrier_US*1.2]); grid on; % Show both LF and HF parts

% Row 4: Sum of 9 Interfering Signals
subplot(4,2,7); plot(t, s_interfere); title('4a. Sum of 9 Interfering LF Signals');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
subplot(4,2,8); plot_spectrum_local(s_interfere, Fs, '4b. Spectrum of Interfering Signals');
xlim([0 100]); grid on;

% --- Figure 2: Mixed Signal, AE Extraction Process & Final Comparison ---
figure('Name', 'Figure 2: AE Extraction Process & Final Result', 'Position', [100, 50, 1200, 1000]); % Made taller for 5 rows
sgtitle('AE Signal Extraction Pipeline & Result', 'FontSize', 15, 'FontWeight', 'bold');

% Row 1: Mixed Signal (as recorded by electrode)
subplot(5,2,1); plot(t, s_mixed); title('1a. Mixed Signal (Local V1 with AE + Interf.)');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
subplot(5,2,2); plot_spectrum_local(s_mixed, Fs, '1b. Spectrum of Mixed Signal');
xlim([0 f_carrier_US*1.5]); grid on;

% Row 2: Band-Passed Signal (Isolating AE Component)
subplot(5,2,3); plot(t, s_bandpassed); title('2a. Band-Passed Signal (Isolating AE)');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
subplot(5,2,4); plot_spectrum_local(s_bandpassed, Fs, '2b. Spectrum of Band-Passed Signal');
xlim([f_carrier_US - 4*f_V1_target_LF, f_carrier_US + 4*f_V1_target_LF]); grid on;

% Row 3: Signal After Multiplication by Local Oscillator
subplot(5,2,5); plot(t, s_multiplied); title('3a. After Multiplication with Local Oscillator');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_detail);
subplot(5,2,6); plot_spectrum_local(s_multiplied, Fs, '3b. Spectrum After Multiplication');
xlim([0 f_carrier_US*2.2]); grid on;

% Row 4: Recovered LF Info from AE (Raw, after LPF)
subplot(5,2,7); plot(t, s_recovered_from_AE_raw); title('4a. Recovered LF Info (Raw, from AE)');
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_full);
subplot(5,2,8); plot_spectrum_local(s_recovered_from_AE_raw, Fs, '4b. Spectrum of Recovered LF Info');
xlim([0 100]); grid on;

% Row 5: Final Comparison (Original V1 LF vs. Scaled Recovered Info)
subplot(5,2,9); plot(t, s_V1_target_LF_ac);
title(['5a. Original V1 LF (', num2str(f_V1_target_LF), ' Hz, AC)']);
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_full);
ylim_final_val = amp_V1_target_LF * 1.1; if isempty(ylim_final_val) || ylim_final_val == 0; ylim_final_val = 1; end; ylim([-ylim_final_val, ylim_final_val]);

subplot(5,2,10); plot(t, s_recovered_from_AE_scaled);
title(['5b. Recovered V1 Info (Scaled AC, from AE)']);
xlabel('Time (s)'); ylabel('Amplitude'); grid on; xlim(xlim_time_full); ylim([-ylim_final_val, ylim_final_val]);

fprintf('Plotting complete. Simulation finished.\n');

% --- Local Function Definition (Place at the VERY END of your .m file) ---
function plot_spectrum_local(signal, Fs_in, title_text)
    L = length(signal);
    if L == 0 || ~all(isfinite(signal(:)))
        plot(NaN,NaN); % Plot nothing visible if signal is bad
        title([title_text, ' (Empty or Non-finite Signal)']);
        xlabel('Frequency (Hz)'); ylabel('Amplitude Spectrum |X(f)|'); grid on; return;
    end
    Y = fft(signal);
    P2 = abs(Y/L);
    P1 = P2(1:floor(L/2)+1);
    P1(2:end-1) = 2*P1(2:end-1); % Single-sided spectrum amplitude
    f_axis = Fs_in*(0:(floor(L/2)))/L;
    plot(f_axis, P1);
    title(title_text);
    xlabel('Frequency (Hz)'); ylabel('Amplitude Spectrum |X(f)|'); grid on;
end